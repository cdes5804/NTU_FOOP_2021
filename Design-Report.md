# Design Report

>  Please follow the instructions in homework 1 (officially announced version on NTU COOL) to finish the report.



### Software Design

The classes are structured into packages, and will be introduced based on the structure.

* #### Entity

  * ***Card***
    * Duty: Defines a card in the game and provides a comparator to compare the order with another card.
    * Interaction with other classes: A card does not initiate interaction with other classes, but it is used by many other classes, which will be introduced in the description of those classes.
  * ***Game***
    * Duty: The controller of the game. Describes the component of a game.
    * Interaction with other classes:
      * ***Card***: A game has a deck consists of 52 cards, and one of them is the starting card.
      * ***Player***: A game consists of 4 players.
      * ***Round***: A game consists of several rounds in which players play their cards.
      * ***PatternFactory***: A game holds a factory that is used to generate legal card patterns.
  * ***Player***
    * Duty: Defines a player in the game, and the action a player can take.
    * Interaction with other classes:
      * ***Card***: A player has several cards that can be played.
      * ***PatternFactory***: When a set of cards is played by a player, the pattern factory will check its pattern.
  * ***Round***:
    * Duty: Defines the game flow of a round.
    * Interaction with other classes:
      * ***Player***: A round requires the players to take action.
      * ***PatternFactory***: Receives it from the ***Game*** object and passes it to the player.

* #### IO

  * ***Reader***
    * Duty: Responsible for handling all the input during a game.
    * Interaction with other classes: A reader returns data to the caller, it serves as an utility.
  * ***Writer***:
    * Duty: Responsible for handling all the output during a game.
    * Interaction with other classes: A writer writes data to the user when needed, it serves as an utility.

* #### Pattern

  * ***PatternBase***
    * Duty: The base class for all patterns and used for polymorphism.
    * Interaction with other classes:
      * ***Card***: Every pattern consists of some cards.
  * ***Single/Pair/Straight/FullHouse***
    * Duty: Inherits ***PatternBase*** and defines the corresponding pattern.
    * Interaction with other classes: A pattern is generated by its factory. It does not initiate interaction with other classes.

* #### Factory

  * ***FactoryBase***
    * Duty: The base class for all factories and used for polymorphism.
    * Interaction with other classes: It is an abstract class with no members and abstract functions to be implemented.
  * ***Single/Pair/Straight/FullHouse Factory***
    * Duty: Identify a legal pattern and generates the corresponding pattern object.
    * Interaction with other classes:
      * ***Card***: Uses cards to generate the pattern object.
      * ***Single/Pair/Straight/FullHouse***: A factory generates the corresponding pattern object.
  * ***PatternFactory***:
    * Duty: Collects all factories and use the appropriate one when receiving a set of cards.
    * Interaction with other classes:
      * ***Cards***: Receives a set of cards and test is against the factories.
  * ***FactoryUtils***
    * Duty: Provides some useful utility functions for factories to use.
    * Interaction with other classes: It is a static utility class and its member functions are called by factories.

### Bonus Software Design

> You will either get 0 or 20 points on this bonus. 

> If you can't achieve it, don't report anything here.

To add another pattern to the game, we have to provide two classes.

We take the pattern ***Flush*** for example.

First we have to create a ***Flush*** class under the **Pattern** package, and it has to inherit ***PatternBase***.

Then we have to implement two functions:

1. `constructor`: Construct the object. Calling `super()` will suffice.
2. `compareTo`: Define the logic to compare a flush to another flush.



After we are done with the ***Flush*** class, we create ***FlushFactory*** under the **Factory** package, and it has to inherit **FactoryBase**.

We have to provide two functions:

1. `construct`: Construct a ***Flush*** object. Using `new` will suffice.
2. `isValidPattern`: Provide the rule that, when given a set of cards, can be used to identify a flush.



After we have created these two classes, the only thing left to change is the main function.

We add a single line of code:  `patternFactory.register(new FlushFactory());` 

This way, ***PatternFactory*** will try to identify the flush pattern and generate the object for us.

In essence, to add a new pattern, we only need to create two new classes and add a single line of code to the main function, without having to modify any character of the existing code.